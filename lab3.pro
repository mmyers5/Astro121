PRO file_orgy, nSamp, voltThreshold, picoArgs, fileTag, correction = nFile
;+
; OVERVIEW
; --------
; Procedure will invoke picosampler however many times specified
; and will label them based on user input. make sure you have a
; directory called "data" in your present working directory. will output
; to a logfile named after the filetag that will contain info about the
; parameters sent to picosampler, subsequently adding the date and time
; when the samples were finished.
; format will be date (month/day), time (24hr), and sample
; number. E.G. the first sample finished on february at 8:59 will be
; laveled as "0211_2059_00" in the log
;
; CALLING SEQUENCE
; ----------------
; file_orgy, nSamp, voltThreshold, picoArgs, fileTag, correction = nFile
;
; PARAMETERS
; ----------
; nSamp: int
;     the number of times you want picosampler to be sampled, or the
;     number of files you want to have by the end
; voltThreshold: string
;     the parameters for picosampler, written as '1V', or '100mV' etc...
; picoArgs: array
;     must be an array specifying the arguments to be passed into 
;     picosampler. recall sequence is VoltThreshold, sampInterval,
;     nSpectra, /dual.  to set /dual, type 1, else type 0. VoltThreshold
;     should be input as an integer
; fileTag: string
;     how you want to label the files. files are named starting with the 
;     file tag, followed by the sample number. E.G. the first file
;     created by picosampler with fileTag 'test' will be 'test_00.bin'
;
; KEYWORDS
; --------
; correction: int
;     if for some reason you stopped taking data and wanted to resume
;     where it left off, then you can invoke this argument to start 
;     doing simulations starting at this numberfile. the number of 
;     times to sample will be reduced by whatever amount is specified
;     in nFile
;- 

sampInterval = picoArgs[1]                        ; unpack the picoArgs list to be put into picosampler
nSpectra = picoArgs[2]
duality = picoArgs[3]

leFreq = 62.5/sampInterval                        ; get sampling frequency
leFreq = string(leFreq, format='(f0.1)')          ; make sure frequencies go up to one decimal digit
IF N_ELEMENTS(nFile) EQ 0 THEN start=0 ELSE start=nFile   ; check if a correction needs to be made

openw, 1, fileTag+'.log', /APPEND                 ; append to log file based on filetag
printf, 1, format='("VoltThreshold", 4X, "sampInterval", 4X, "nSpectra", 4X, "dual")'
printf,1,  format='(A13,I16,I12,I8)', voltThreshold, sampInterval, nSpectra, duality
close, 1

FOR i=start, start+nSamp-1 DO BEGIN                     ; recall both start and end indices are inclusive
   filename = picosampler(voltThreshold, sampInterval, nSpectra, dual = duality) ; call picosampler
   
   timeTag = systime(/JULIAN)                     ; get julian time
   caldat, timeTag, mo, day, yr, hr, min, sec     ; unpack time
   
   openw, 1, fileTag+'.log', /APPEND              ; add info about time to logfile
   printf, 1, format='(I02, I02, "_", I02, I02, "_", I02)',$
           mo, day, hr, min, i
   close, 1

   destination = STRJOIN(STRSPLIT(fileTag+'_'+$
                                  string(i, format='(I02)')+$
                                  '.bin', /EXTRACT)) ; put filename together and extract whitespaces
   file_link, filename, './data/'+destination        ; create a symbolic link to file using destination name

ENDFOR

END

PRO channel_sort, fileTag, nFiles, nSpectra, specArr
;+
; OVERVIEW
; --------
; procedure will read incremental files as generated by picosampler,
; then will combine all the spectra from each file into one spectrum.
; it does this by taking the median of each spectra with the spectrum
; next following it, which leads to one file spectrum. each file
; spectrum is then median'd with the next file spectrum. 
; may have to increase the "distance" between spectra in case this does
; too much smoothing, but as it stands it looks like IDL can only handle
; an array with 2 rows and 16K elements each row
;
; CALLING SEQUENCE
; ----------------
; channel_sort, fileTag, nFiles, nSpectra, specArr
;
; PARAMETERS
; ----------
; fileTag: string
;     must be the fileTag used in file_orgy procedure to help user
;     select the binary files that need the channels sorted
; nFiles: int
;     the number of binary files labeled with fileTag. Must be
;     incremental
; nSpectra: int
;     give the number of spectra used when you used picosampler. Should
;     have been output to a .log file if used file_orgy to call
;     picosampler
;
; OUTPUTS
; -------
; specArr: list
;     an array containing one spectrum, the "averaged" spectrum from all
;     the spectra you took. be glad.
;-

print, 'start: '+systime()
N=ulong(32000)                  ; number of elements per picosampler binary file

FOR i=0, nFiles-1 DO BEGIN      ; loop through every file and get a smooth spectrum from every file   
                                ; will end up with one spectrum

   j = string(i, FORMAT='(I02)')               ; get filenumber in proper string format

   filename = './data/'+fileTag+'_'+j+'.bin'   ; put filename together for reading the binary
   
   binArr = read_binary(filename, data_type=2) ; read binary file   
   bigN = ulong(size(binArr, /N_ELEMENTS))     ; the size of the entire array

   FOR spec=0, nSpectra-1 DO BEGIN             ; for every spectra in every file

      reStart = spec*(N/2)                     ; starting point of each spectrum, real
      reEnd = reStart + (N/2)-1                ; ending, real

      imStart = reStart + (bigN/2)             ; starting point of each imaginary spectrum 
      imEnd = imStart + (N/2)-1                ; ending, imaginary
                                                
      power_spec, binArr[reStart:reEnd],$      ; will get the power spectrum from procedure
                  binArr[imStart:imEnd],$      ; output in powerArr, shape [(N/2)]
                  powerArr
      
      IF specArr EQ !NULL THEN BEGIN           ; check if specarray exists

         specArr = powerArr                    ; initialize array to first spectrum

      ENDIF ELSE BEGIN

         specArr = [[specArr],[powerArr]]      ; append to specArr, rows will be diff. spectra

         IF spec MOD 500 EQ 0 THEN BEGIN       ; for every 100 spectra

            specArr = median(specArr,$         ; take median over every data point from each spectrum
                             DIMENSION=2)      ; resets to shape [(N/2)]   
         ENDIF

      ENDELSE

   ENDFOR       ; for loop for every spectrum  

ENDFOR          ; for loop for every file

print, 'end: '+systime()
END

PRO power_spec, realArr, imagArr, specPF

;+
; OVERVIEW
; --------
; procedure will take power spectra of input arrays and shift them to be
; centered accordingly
;
; CALLING SEQUENCE
; ----------------
; power_spec, realArr, imagArr, specPF
;
; PARAMETERS
; ----------
; realArr: array
;     input array from channel 1
; imagArrArr: array
;     input array from channel 2
; 
; OUTPUTS
; -------
; specPF: array
;     the power spectrum of the input array
;-

compArr = complex(realArr, imagArr)            ; make one giant mega-complex array

specFT = fft(compArr)                          ; take fourier transform of complex array
N = size(specFT, /N_ELEMENTS)
specFT = shift(specFT, N/2)                    ; shift ft to be centered on zero

specPF = (abs(specFT))^2                       ; take power spectrum

END

PRO smoothies, theArrays, rowCount, numChan, outDid
;+
; OVERVIEW
; --------
; will take in a list of arrays that you want to be smoothed
; will be smoothed over every row (second index)
;
; CALLING SEQUENCE
; ----------------
; smoothies, theArrays, rowCount, numChan, outDid
;
; PARAMETERS
; ----------
; theArrays: list
;     the list of arrays. should be 2d, with every row (second
;     index) being a different array
; rowCount: integer
;     the number of rows in theArrays
; numChan: integer
;     the number of channels over which you would like your smoothie
; 
; OUTPUTS
; -------
; outDid: list
;     the list of output arrays, median'd over
;-

outDid = theArrays

FOR i =0, rowCount-1 DO BEGIN

   outDid[*,i] = median(theArrays[*,i], numChan)

ENDFOR

END

FUNCTION smooth_operator, onArray, offArray, coldArray, hotArray, numChan
;+
; OVERVIEW
; --------
; will take the median of arrays for smoothing stuff and put them
; together to get the final final final array we're looking for
;
; CALLING SEQUENCE
; ----------------
; smooth_operator, onArray, offArray, coldArray, hotArray, numChan, finalArray
;
; PARAMETERS
; ----------
; onArray: array
;     should be power spectrum from online data
; offArray: array
;     should be power spectrum from offline data
; coldArray: array
;     power spectrum of data of the cold unforgiving sky
; hotArray: array
;     power spectrum of data from our portable sacks of water
; numChan: int
;     number of channels over which you would like the median to be
;     measured
;
; OUTPUTS
; -------
; finalArray: array
;     the output array after it has been smoothed
;-

onArray = median(onArray, numChan)            ; median over online data
offArray = median(offArray, numChan)           ; median over offline data

scoldArray = median(coldArray, numChan)             ; median over cold data
shotArray = median(hotArray, numChan)               ; median over hot data

ratio = onArray/offArray
Tsys = (total(scoldArray)/total(shotArray - scoldArray) )*(300) ; get Tsys, look at pg 6 of lab thing

RETURN, finalArray = ratio*Tsys

END

PRO cheating_doppler, JT, delF
;+
; OVERVIEW
; --------
; will calculate the doppler shifted frequency change using a cheaty
; method
;
; CALLING SEQUENCE
; ----------------
; cheating_doppler, JT, delF
;
; PARAMETERS
; ----------
; JT: float
;     the julian time at which you want this calculated
;
; OUTPUTS
; -------
; delF: float
;     the change in frequency due to the doppler shifting!

lati = 37.8717                                    ; latitude of Berkeley
longi = 122.2728                                  ; longitude of Berkeley
tz = 8                                            ; time zone of Berkeley

zenpos, JT, ra, dec             ; call cheating procedure
                                ; it will ask you to input lati, longi,
                                ; and tz

ra = ra*(180./!pi)*(24/360.)                      ; convert to decimal hours
dec = dec*(180./!pi)                              ; convert to decimal degrees

vel = ugdoppler(ra, dec, JT)                      ; call doppler shift procedure
c = 3.e8

delF = -1*(v/c)*(1420.4058)                       ; gives delta f in MHz

END  
