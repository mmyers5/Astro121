FUNCTION dopp_spec, logFile, filArr
;+
; OVERVIEW
; --------
; will read the logfile specified by a particular fileTag and grab relevant data
;	to doppler shift the spectra that presumably belong to the logfile
;
;	CALLING SEQUENCE
;	----------------
;	result = dopp_spec(logFile, filArr)
;
;	PARAMETERS
;	----------
;	logFile: string
;			the full filename of the logFile that was generated by the observation in
;			track_head
;	filArr: list
;			the spectra from each file, see function below
;
; OUTPUTS
; -------
;	pirateArr: list
;			the final arrrrrray corrected for doppler shifts. each row is a spectrum
;			from a file
;-
	readcol, logFile, j, ra, dec, jDay   ; read logfile, j is number of file
                                       ; (ra,dec) in degrees in 2000 equinox
                                       ; jDay is normal
	ra *= (24./360)                      ; convert ra to decimal hours
	velo = ugdoppler(ra, dec, jDay, nlat =37.8732, wlong=122.2573)  ; DOPP-IT!
END	
FUNCTION map_spec, fileTag, nFiles, nSpectra
;+
; OVERVIEW
; --------
; function will read all the files generated by leuschner_rx that has a fileTag.
; assumes the files are incremented regularly. then smooths and calibrates the
;	spectra in each file and stores the smoothed spectra in an array
;
; CALLING SEQUENCE
; ----------------
; result = map_spec(fileTag, nFiles, nSpectra)
;
; PARAMETERS
; ----------
; fileTag: string
; 		assumes that the data files are in ./data, is the fits file for spec
;     incremented up to three digits of precision, i.e. 'fileTag_001', where
;			diode status is contained in fileTag
;     if for some reason not starting from file 000, do special sheisse
; nFiles: integer
;			the number of files you got
; nSpectra
;			the number of spectra in each fits file, or extension number
;
; OUTPUTS
; -------
; filArr: list
; 		array containing smoothed and calibrated spectra of each file
;     each row is a file
;-
	N = 8192
	filArr = make_array(N, nFiles)         ; holds spectra for each file
                                         ; each row is a file
	FOR i=0, nFiles-1 DO BEGIN
		j = STRING(i, FORMAT='(I03)')        ; get increment value
		fileTagx = './data/'+fileTag+'_'+j   ; for passing into channel_sort
		filArr[*,i] = channel_sort(fileTagx, nSpectra)  ; get spectrum in file
	ENDFOR
	RETURN, filArr
END

FUNCTION channel_sort, fileTagx, nSpectra 
;+
; OVERVIEW
; --------
; function will read files as generated by leuschner_rx,
; then will combine all the spectra from each file into one spectrum after
; calibraton. currently only uses the spectra from auto0_real
;
; CALLING SEQUENCE
; ----------------
; result = channel_sort(fileTagx, nSpectra)
;
; PARAMETERS
; ----------
; fileTagx: string
;     assumes that the data files are in ./data, is the fits file for spec
;     typical name: 'fileTagx_on.fits', x = '_increment number'
; nSpectra: int
;     give the number of spectra used when you used leuschner_rx. same as
;     extension number for using mrdfits
;
; OUTPUTS
; -------
; specArr: list
;     an array containing the smoothed and calibrated spectra 
;-
	N = 8192                         ; the number of elements from each extension
	extArr = make_array(N, nSpectra) ; holds spectra from extensions of one file
                                   ; each row is an extension
	onFil = fileTagx+'_'+on+'.fits'          ; for on spectra
	offFil = fileTagx+'_'+off+'.fits'        ; for off spectra
	FOR k=1, nSpectra DO BEGIN                       ; loop through each ext
		onTemp = (mrdfits(onFil,k)).auto0_real         ; unpack ext on spec
		offTemp = (mrdfits(offFil,k)).auto0_real       ; unpack ext off spec
		extArr[*,k-1] = calib(onTemp, offTemp)         ; calib spec and store
	ENDFOR
	specArr = median(extArr, DIMENSION = 2)          ; smooth extensions and store
  RETURN, specArr
END

FUNCTION calib, onSpec, offSpec
;+ 
; OVERVIEW
; --------
; will calibrate spectra
;
; CALLING SEQUENCE
; ----------------
; result = calib(onSpec, offSpec)
;
; PARAMETERS
; ----------
; onSpec: list
;     the online spectrum
; offSpec: list
;     the offline spectrum
;
; OUTPUTS
; -------
; calSpec: list
;     the final calibrated spectrum
;-
	coldSpec = mrdfits('./data/coldSpec.fits', 1)          ; spectrum of cold sky
	hotSPec = mrdfits('./data/hotSpec.fits', 1)            ; spectrum with diode on
	ratio = onSpec/offSpec                                 ; get shape of line
	Tsys = (total(coldSpec)/total(hotSpec-coldSpec)) * 20  ; sys temperature
	calSpec = ratio*Tsys                               ; final calibrated spectrum
	RETURN, calSpec
END
