PRO dopp_spec, logFile, loFreq, velo, freq
;+
; OVERVIEW
; --------
; will read the logfile specified by a particular fileTag and grab relevant data
; to doppler shift the spectra that presumably belong to the logfile
;
; CALLING SEQUENCE
; ----------------
; dopp_spec, logFile, loFreq, velo, freq
;
; PARAMETERS
; ----------
; logFile: string
;     the full filename of the logFile that was generated by the observation in
;     track_head
; loFreq: float
;     the local oscillator frequency used, set by set_lhp()
;
; OUTPUTS
; -------
; velo: list
;     the array of the doppler velocities
; freq: list
;     the doppler shifted frequency axis for the files specified by logfile
;-
  N = 8192                                 ; get number of elements per spectrum
  sampFreq = 24d6                          ; sampling frequency
  readcol, logFile, j, ra, dec, jDay       ; read logfile, j is number of file
                                           ; (ra,dec) in degrees in 2000 equinox
                                           ; jDay is normal
  ra *= (24./360)                          ; convert ra to decimal hours
  velo = ugdoppler(ra, dec, jDay, nlat =37.8732, wlong=122.2573)  ; DOPP-IT!
  doppFreq = (loFreq*c)/velo
  freq = (findgen(N)-(N/2))*(sampFreq/N)   ; get frequency axis
  freq += doppFreq                         ; doppler shift the axis
END 

FUNCTION map_spec, fileTag, nFiles, nSpectra
;+
; OVERVIEW
; --------
; function will read all the files generated by leuschner_rx that has a fileTag.
; assumes the files are incremented regularly. then smooths and calibrates the
; spectra in each file and stores the smoothed spectra in an array
;
; CALLING SEQUENCE
; ----------------
; result = map_spec(fileTag, nFiles, nSpectra)
;
; PARAMETERS
; ----------
; fileTag: string
;     assumes that the data files are in ./data, is the fits file for spec
;     incremented up to three digits of precision, i.e. 'fileTag_001', where
;     diode status is contained in fileTag
;     if for some reason not starting from file 000, do special sheisse
; nFiles: integer
;     the number of files you got
; nSpectra
;     the number of spectra in each fits file, or extension number
;
; OUTPUTS
; -------
; filArr: list
;     array containing smoothed and calibrated spectra of each file
;     each row is a file
;-
  N = 8192
  filArr = make_array(N, nFiles)         ; holds spectra for each file
                                         ; each row is a file
  FOR i=0, nFiles-1 DO BEGIN
    j = STRING(i, FORMAT='(I03)')        ; get increment value
    fileTagx = './data/'+fileTag+'_'+j   ; for passing into channel_sort
    filArr[*,i] = channel_sort(fileTagx, nSpectra)  ; get spectrum in file
  ENDFOR
  RETURN, filArr
END

FUNCTION channel_sort, fileTagx, nSpectra 
;+
; OVERVIEW
; --------
; function will read files as generated by leuschner_rx,
; then will combine all the spectra from each file into one spectrum after
; calibraton. currently only uses the spectra from auto0_real
;
; CALLING SEQUENCE
; ----------------
; result = channel_sort(fileTagx, nSpectra)
;
; PARAMETERS
; ----------
; fileTagx: string
;     assumes that the data files are in ./data, is the fits file for spec
;     typical name: 'fileTagx_on.fits', x = '_increment number'
; nSpectra: int
;     give the number of spectra used when you used leuschner_rx. same as
;     extension number for using mrdfits
;
; OUTPUTS
; -------
; specArr: list
;     an array containing the smoothed and calibrated spectra 
;-
  N = 8192                          ; the number of elements from each extension
  extArr0 = make_array(N, nSpectra) ; holds spectra from extensions of one file
                                    ; each row is an extension
  extArr1 = make_array(N, nSpectra)
  onFil = fileTagx+'_'+on+'.fits'          ; for on spectra
  offFil = fileTagx+'_'+off+'.fits'        ; for off spectra
  FOR k=1, nSpectra DO BEGIN         
    onSpec = mrdfits(onFil,k)           ; unpack ext on
    offSpec = mrdfits(offFil,k)         ; unpack ext off
    extArr0[*,k-1] = calib(onSpec.auto0_real, offSpec.auto0_real) ; calibrate
    extArr1[*,k-1] = calib(onSpec.auto1_real, offSpec.auto1_real) ; and store
  ENDFOR
  specArr = median([[extArr0],[extArr1]], DIMENSION = 2)  ; smooth the things 
  RETURN, specArr
END

FUNCTION calib, onSpec, offSpec
;+ 
; OVERVIEW
; --------
; will calibrate spectra
;
; CALLING SEQUENCE
; ----------------
; result = calib(onSpec, offSpec)
;
; PARAMETERS
; ----------
; onSpec: list
;     the online spectrum
; offSpec: list
;     the offline spectrum
;
; OUTPUTS
; -------
; calSpec: list
;     the final calibrated spectrum
;-
  coldSpec = mrdfits('./data/coldSpec.fits', 1)          ; spectrum of cold sky
  hotSPec = mrdfits('./data/hotSpec.fits', 1)            ; spectrum with diode on
  ratio = onSpec/offSpec                                 ; get shape of line
  Tsys = (total(coldSpec)/total(hotSpec-coldSpec)) * 20  ; sys temperature
  calSpec = ratio*Tsys                               ; final calibrated spectrum
  RETURN, calSpec
END
